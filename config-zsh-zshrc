#
# doug murray : 07-Mar-2020
#
# Change History
#       16-Nov-96 cleared ancient history entries to 23-Jan-81
#       07-Mar-18 finally updated echo to printf where possible
#       25-Oct-18 port to zsh
#

#
# Common startup for shells
#
#   Names starting with '_' are meant to be private
#

#
# Before anything else, locate the
# startup directory, assumed to be
# the same one from which this
# script is running.
#
# Check if we're running from bash by
# checking for shopt, a bash builtin.
#
if type shopt &>/dev/null
then
        _STARTUP_DIR=$(readlink -f $(dirname $(readlink -f ${BASH_SOURCE[0]})))
        HISTFILE="${_STARTUP_DIR}/bash-history"
        HISTFILESIZE=5000 # maximum size of saved history file
else
        _STARTUP_DIR=$(readlink -f $(dirname $(readlink -f ${(%):-%x})))
        HISTFILE=${_STARTUP_DIR}/zsh-history
        SAVEHIST=5000     # maximum size of saved history file
        ZDOTDIR=${_STARTUP_DIR}
fi

#
# customizable settings
#

HISTSIZE=5000             # maximum history size in memory per session

USECOLOR=true             # let 'ls' and 'grep' use color if available
WINDOWHEADER="yes"        # display CWD in xterm/sun-cmd window header
SHOWGITBRANCH="yes"       # display git branch in xterm/sun-cmd window header

USERID=${UID:-"$(id -u)"} # will check for root or reserved IDs
OSTYPE="$(uname -s)"      # Linux, Darwin (MacOS), no longer check for Solaris, HPUX
TTY=$(tty)                # will check for interactive session

SYS_SPECIFIC=''
HIST_STAMPS="yyy-mm-dd"
COMPLETION_WAITING_DOTS="true"
DISABLE_UNTRACKED_FILES_DIRTY="true"
PREVIOUSLY_VISITED_DIRS="${_STARTUP_DIR}/previousDirs"

unsetopt notify
setopt PROMPT_SUBST

autoload -Uz vcs_info
zstyle ':vcs_info:git*' enable git
zstyle ':vcs_info:git*' stagedstr '>'
zstyle ':vcs_info:git*' unstagedstr '+'
zstyle ':vcs_info:git*' formats '%b %u%c'

zstyle :compinstall filename '${_STARTUP_DIR}/.zshrc'
autoload -Uz compinit
compinit

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#
# Generic Setup
#

function setupCommands
        {

        alias cp='cp -i'
        alias mv='mv -i'
        alias rm='rm -i'
        alias j='jobs -l'
        alias h='history -20'

        alias source=.
        alias up=uptime
        alias z='printf "%s\n" "pid=$$ $SHELLNAME";suspend'

        #
        # BUILDKIT refers to docker build utility
        #
        export EDITOR=vi
        export BUILDKIT_COLORS="run=cyan:cancel=yellow:warning=red"

        #
        # color definitions for 'ls', 'grep' and autocompletion
        #
        newlist color LS_COLORS -e

        addcolor 'no=00'
        #
        # system criteria (alphabetic)
        #
        addcolor 'bd=00;91'             # block device
        addcolor 'ca=00;91'             # capabilities have been set (?)
        addcolor 'cd=01;96'             # character device
        addcolor 'di=01;95'             # directory
        addcolor 'do=01;35'             # Solaris DOOR
        addcolor 'ex=01;32'             # executable
        addcolor 'fi=01;36'             # file
        addcolor 'ln=01;36'             # link (hard or symbolic)
        addcolor 'mh=00'                # multiple hard links exist
        addcolor 'or=40;31;01'          # orphan - symlink to nowhere
        addcolor 'ow=04;1;32'           # other-writable (002) and not sticky
        addcolor 'tw=04;1;32'           # other-writable (002) and sticky
        addcolor 'pi=40;33'             # named pipe or fifo
        addcolor 'rs=0'                 # reset code (?)
        addcolor 'sg=30;43'             # set GID bit set
        addcolor 'so=01;35'             # socket endpoint
        addcolor 'st=37;44'             # sticky bit
        addcolor 'su=37;41'             # set UID bit set
        #
        # filename criteria (alphabetic)
        #
        addcolor '*.bmp=00;35'          # BMP image file (Bitmap Image File)
        addcolor '*.cpio=00;31'         # CPIO file package
        addcolor '*.csh=00;32'          # C-shell script
        addcolor '*.doc=00;35'          # Microsoft Word Document
        addcolor '*.docx=00;35'         # Microsoft Word Document
        addcolor '*.gif=00;35'          # GIF image file (Graphics Interface Format)
        addcolor '*.gz=00;31'           # GNU compressed file (gzip)
        addcolor '*.jpg=00;35'          # JPEG image file (Joiint Photographic Experts Group)
        addcolor '*.png=00;35'          # Portable Network Graphics file
        addcolor '*.ppt=00;35'          # Microsoft PowerPoint Document
        addcolor '*.pptx=00;35'         # Microsoft PowerPoint Document
        addcolor '*.rpm=00;31'          # RedHat package manager
        addcolor '*.sh=00;32'           # shell script
        addcolor '*.tar=00;31'          # tar file (Tape ARchive)
        addcolor '*.tgz=00;31'          # compressed tar file (gzipped tar)
        addcolor '*.tif=00;35'          # TIFF file (Tag Image File Format)
        addcolor '*.tz=00;31'           # compressed tar file
        addcolor '*.xbm=00;35'          # X Bitmap File (X11 windowing system)
        addcolor '*.xls=00;35'          # Microsoft Excel Document
        addcolor '*.xlsx=00;35'         # Microsoft Excel Document
        addcolor '*.xpm=00;35'          # X Pixmap File (X11 windowing system)
        addcolor '*.zip=00;31'          # compressed file (zip)

        case "$OSTYPE" in
                "Linux")
                        #
                        # See if we can be more specific about the distribution
                        #
                        if [[ -r "/etc/os-release" ]];
                        then
                                SYS_SPECIFIC=$(grep '^ID='<"/etc/os-release"|sed -e 's/^ID=\(.*\)/\1/')
                        else
                                SYS_SPECIFIC=Linux
                        fi

                        #
                        # check for the GNU version of ls
                        #
                        if [[ $USECOLOR = "true" ]];
                        then
                                "grep" "--version" 2>&1|grep coreutils>/dev/null
                                err=$?
                                if (( $err == 0 ))
                                then
                                        export GREP_COLORS='ms=01;32'
                                        alias grep='grep --color=auto'
                                fi

                                "ls" "--version" 2>&1|grep coreutils>/dev/null
                                err=$?
                                if (( $err == 0 ))
                                then
                                        alias ls='ls --color=auto -F'
                                fi
                        else
                                unalias ls   &>/dev/null
                                unalias grep &>/dev/null
                        fi
                        ;;
                "Darwin")
                        SYS_SPECIFIC="MacOS"

                        #
                        # check for grep and ls colorization
                        #
                        if [[ $USECOLOR = "true" ]];
                        then
                                #
                                # LSCOLORS unknown in zsh
                                #
                                alias grep='grep --color=auto'

                                #
                                # MacOS Filesystem Entry Attributes
                                #   Position    Purpose
                                #       1       Directory
                                #       2       symbolic link
                                #       3       socket
                                #       4       named pipe
                                #       5       executable
                                #       6       block device
                                #       7       character device
                                #       8       executable with set UID
                                #       9       executable with set GID
                                #      10       Directory other-writable (002) with sticky bit
                                #      11       Directory other-writable (002) without sticky bit
                                #
                                # MacOS Color Attributes (foreground first, background second)
                                #            (eg 'Cx' yields Bold Green on default background)
                                #   Code        Color
                                #     a         Black
                                #     b         Red
                                #     c         Green
                                #     d         Brown
                                #     e         Blue
                                #     f         Magenta
                                #     g         Cyan
                                #     h         Light Grey
                                #     A         Dark Grey
                                #     B         Bold Red
                                #     C         Bold Green
                                #     D         Bold Brown (Yellow)
                                #     E         Bold Blue
                                #     F         Bold Magenta
                                #     G         Bold Cyan
                                #     H         Bright White
                                #     x         Default
                                #
                                export LSCOLORS="CxgxGxGxDxAxhxBxBxBxBx"

                                alias ls='ls --color=auto -F'
                                zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}
                        else
                                unalias ls &>/dev/null
                        fi

                        newlist maclib DYLD_LIBRARY_PATH
                        addmaclib -q ~/Dropbox/src/xcode-local/lib
                        addmaclib -q ~/Dropbox/src/lib
                        export EPICS_BASE=${EPICS_BASE:-"/usr/local/epics/base"}
                        EPICS_SETUP=${EPICS_BASE}/config/epicsSetup.bash
                        if [[ -e $EPICS_SETUP ]];
                        then
                                source $EPICS_SETUP
                        else
                                if [[ "$(arch)" = "arm64" ]];
                                then
                                        _macArch="darwin-aarch64"
                                else
                                        _macArch="darwin-x86"
                                fi
                                export EPICS_HOST_ARCH=${EPICS_HOST_ARCH:-"${_macArch}"}
                                addpath -q ${EPICS_BASE}/bin/${EPICS_HOST_ARCH}/
                                unset _macArch
                        fi

                        #
                        # Support for OpenDDS
                        #
                        if [[ -d ~/Dropbox/OpenDDS ]];
                        then
                                export DANCE_ROOT=unused
                                export CIAO_ROOT=unused
                                export DDS_ROOT=~/Dropbox/OpenDDS/OpenDDS-3.12
                                export ACE_ROOT=~/Dropbox/OpenDDS/OpenDDS-3.12/ACE_wrappers
                                export TAO_ROOT=~/Dropbox/OpenDDS/OpenDDS-3.12/ACE_wrappers/TAO
                                export MPC_ROOT=~/Dropbox/OpenDDS/OpenDDS-3.12/ACE_wrappers/MPC
                                addmaclib -q ${DDS_ROOT}/lib
                                addpath -q ${DDS_ROOT}/bin
                                addmaclib -q ${ACE_ROOT}/lib
                                addpath -q ${ACE_ROOT}/bin
                        fi

                        #
                        # Support for RTI DDS
                        #
                        if [[ -d /Applications/rti_connext_dds-5.3.1 ]];
                        then
                                export NDDSHOME=/Applications/rti_connext_dds-5.3.1
                                addpath -q ${NDDSHOME}/bin
                                addlib -q ${NDDSHOME}/lib/x64Darwin17clang9.0/
                                addmaclib -q ${NDDSHOME}/lib/x64Darwin17clang9.0/
                        fi
                        ;;
                *)
                        SYS_SPECIFIC=''
                        ;;
        esac
        }

#
# print a list of defined functions
#
function showFunctions
        {

        print -l ${(ok)functions}
        }

#
# read commands from file if present
#
function _checkAndRead
        {

        for fileName in "$@";
        do
                if [[ -r "$fileName" ]];
                then
                        source "$fileName"
                fi
        done
        }

function findVim
        {

        alias nv='nvim'
        case "$OSTYPE" in
                "Linux")
                        if type gvim &>/dev/null
                        then
                                alias vi='gvim'
                        else
                                if type vim &>/dev/null
                                then
                                        alias vi='vim'
                                else
                                        unalias vi &>/dev/null
                                fi
                        fi
                        ;;
                "Darwin")
                        if type mvim &>/dev/null
                        then
                                alias vi='mvim'
                        else
                                if type vim &>/dev/null
                                then
                                        alias vi='vim'
                                else
                                        unalias vi &>/dev/null
                                fi
                        fi

                        if type newlist &>/dev/null
                        then
                                newlist maclib DYLD_LIBRARY_PATH
                        fi
                        ;;
                *)
                        if type vim &>/dev/null
                        then
                                alias vi='vim'
                        else
                                unalias vi &>/dev/null
                        fi
                        ;;
        esac
        }

#-=-=-=-=-=-=-=-=
# zsh-lists
_checkAndRead "${_STARTUP_DIR}"/newlist.sh

#-=-=-=-=-=-=-=-=

#
# Create list functions
#
newlist path   PATH
newlist cd     CDPATH
newlist man    MANPATH
newlist class  CLASSPATH -n
newlist edm    EDMDATAFILES -e
newlist lib    LD_LIBRARY_PATH
newlist ca     EPICS_CA_ADDR_LIST -s' ' -e
newlist pva    EPICS_PVA_ADDR_LIST -s' ' -e

#
# Add to various lists
#
addlib -q /usr/local/lib

inspath -q /usr/local/bin
inspath -q /usr/local/opt/bison/bin
inspath -q /usr/local/opt/python/libexec/bin
addpath -q ~/bin
addpath -q /bin
addpath -q /usr/bin
addpath -q /usr/afsws/bin
addpath -q /sw/bin
addpath -q /opt/Qt/6.8.0/macos/bin
addca 134.79.219.255
addca 172.26.97.63

#
# Support for Wine
#
addpath -q /opt/usr/bin

if [[ $USERID -eq 0 ]];
then
        addpath -q /sw/sbin
        addpath -q /sbin
        addpath -q /usr/sbin
        addpath -q ~/sbin
fi

insman -q /usr/local/man
addman -q /usr/share/man
addman -q /usr/kerberos/man
addman -q /usr/share/doc/libtiff-devel-3.7.1/html/man
addman -q /usr/share/doc/PyXML-0.8.4/man
addman -q /usr/share/doc/xorg-x11-doc-6.8.2/man
addman -q /usr/share/doc/kernel-doc-2.6.12/Documentation/DocBook/man
addman -q /usr/share/doc/festival-devel-1.95/speech_tools/doc/man
addman -q /usr/share/man
addman -q /usr/share/linuxdoc-tools/dist/linuxdoc-tools/man
addman -q /usr/share/pvm3/man
addman -q /usr/share/eclipse/plugins/org.python.pydev_0.9.3/PySrc/ThirdParty/logilab/pylint/man
addman -q /usr/local/src/openafs-1.2.13/src/man
addman -q /usr/local/share/man
addman -q /var/cache/man
addman -q /etc/gconf/gconf.xml.defaults/schemas/desktop/gnome/url-handlers/man
addman -q /etc/gconf/gconf.xml.defaults/desktop/gnome/url-handlers/man
addman -q /home/rtems/rtems4.7/man
addman -q /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/share/man

#-=-=-=-=-=-=-=-=

#
# zsh-git
#
# git support for xterm, prompts and setup
#

function _git-ahead-behind
        {

        curr_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null);
        curr_remote=$(git config branch.$curr_branch.remote 2>/dev/null);
        curr_merge_branch=$(git config branch.$curr_branch.merge 2>/dev/null|cut -d / -f 3);
        git rev-list --left-right --count $curr_branch...$curr_remote/$curr_merge_branch 2>/dev/null|tr -s '\t' '|';
        }

function git-branch-name
        {

        git branch 2>/dev/null|sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'
        }

function git-branch
        {
        GITBRANCH=$(git-branch-name)
        if [[ -z "$GITBRANCH" ]];
        then
                GITBRANCH="no repo"
        fi
        printf "%s" "$GITBRANCH"
        }

function git-offset
        {
        GITBRANCH=$(git-branch-name)
        if [[ -z "$GITBRANCH" ]];
        then
                GITOFFSETS="0|0"
        else
                GITOFFSETS=$(_git-ahead-behind)
        fi
        printf "$GITOFFSETS"
        }

function git-text
        {
        GITBRANCH=$(git-branch-name)
        if [[ -z "$GITBRANCH" ]];
        then
                GITBRANCH="no repo"
                GITOFFSETS="0|0"
        else
                GITOFFSETS=$(_git-ahead-behind)
        fi
        printf "[$GITBRANCH $GITOFFSETS]"
        }

function git-personal()
        {
        git config --global user.name 'drdoug'
        git config --global user.email 'drdoug@mimeticsystems.com'
        }

function git-slac()
        {
        git config --global user.name 'Doug Murray'
        git config --global user.email 'drm@slac.stanford.edu'
        }

alias gitname='git config user.name;git config user.email'
alias gits='git-text;printf " ";git status'
alias gitl="git log --graph --decorate --oneline --all"
alias gitadd='git add $(git diff --name-only|sort -u)'
alias gitcheck='git remote -v update'

#-=-=-=-=-=-=-=-=

#
# vim rules the airwaves
#

bindkey -v

bindkey '^P' up-history
bindkey '^N' down-history
bindkey '^?' backward-delete-char
bindkey '^h' backward-delete-char
bindkey '^w' backward-kill-word
bindkey '^r' history-incremental-search-backward

function zle-line-finish
        {

        print -n -- "\E]50;CursorShape=0\C-G"  # block cursor
        }

function zle-keymap-select zle-line-init
        {

        case $KEYMAP in
        vicmd)
                EDIT_MODE_PROMPT="E"
                psvar[${PSV_VI}]=$EDIT_MODE_PROMPT
                print -n -- "\E]50;CursorShape=0\C-G"  # block cursor
                ;;
        viins)
                EDIT_MODE_PROMPT='I'
                psvar[${PSV_VI}]=$EDIT_MODE_PROMPT
                print -n -- "\E]50;CursorShape=1\C-G"  # line cursor
                ;;
        main)
                EDIT_MODE_PROMPT=''
                psvar[${PSV_VI}]=$EDIT_MODE_PROMPT
                print -n -- "\E]50;CursorShape=0\C-G"  # block cursor
                ;;
        viopp)
                EDIT_MODE_PROMPT="O"
                psvar[${PSV_VI}]=$EDIT_MODE_PROMPT
                ;;
        visual)
                EDIT_MODE_PROMPT="V"
                psvar[${PSV_VI}]=$EDIT_MODE_PROMPT
                ;;
        *)
                EDIT_MODE_PROMPT="${KEYMAP}"
                psvar[${PSV_VI}]=$EDIT_MODE_PROMPT
                ;;
        esac
        zle reset-prompt
        }

zle -N zle-line-init
zle -N zle-line-finish
zle -N zle-keymap-select
KEYTIMEOUT=5

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#
# Prompting
#

COLORTABLE=${_STARTUP_DIR}/colorTable

PROMPT_ID='\uEA6C'
PROMPT_LOCK='\uF023'
PROMPT_OTHER='\uF109'
PROMPT_LINUX='\uE712'
PROMPT_MACOS='\uF302'
PROMPT_UBUNTU='\uF31B'
PROMPT_REDHAT='\uF316'
PROMPT_CENTOS='\uF304'
PROMPT_GIT_BRANCH='\uE0A0'
PROMPT_R_UP_TRANSITION='\uE0BA'
PROMPT_L_UP_TRANSITION='\uE0BC'
PROMPT_BLOCK_TRANSITION='\uE0CC'
PROMPT_R_DOWN_TRANSITION='\uE0BE'
PROMPT_L_DOWN_TRANSITION='\uE0B8'
PROMPT_R_SPIKE_TRANSITION='\uE0CA'
PROMPT_L_SPIKE_TRANSITION='\uE0C8'
PROMPT_R_FLAME_TRANSITION='\uE0C2'
PROMPT_L_FLAME_TRANSITION='\uE0C0'
PROMPT_R_PIXEL_TRANSITION='\uE0C5'
PROMPT_L_PIXEL_TRANSITION='\uE0C4'
PROMPT_R_CURVE_TRANSITION='\uE0B6'
PROMPT_L_CURVE_TRANSITION='\uE0B4'
PROMPT_R_ARROW_TRANSITION='\uE0B2'
PROMPT_L_ARROW_TRANSITION='\uE0B0'
#PROMPT_COMMIT='\uF151'         #stagedstr
#PROMPT_STAGE='\uF01B'          #unstagedstr
#PROMPT_BRANCH='\uE725'         #branch

#
# determine is label over the given
# color should be bblack or white
#
function isBackgroundDark
        {
        local i=$1

        if (( i == 4 || i == 12 ))
        then
                return 1
        fi

        if (( i >= 232 && i <= 243 ))
        then
                return 1
        fi

        if (( i <= 16 && i % 8 < 2 ))
        then
                return 1
        fi

        if (( i >= 17 && i <= 231 ))
        then
                (( i -= 16 ))
                if (( ( i % 6 * 11 + i / 6 % 6 * 14 + i / 36 * 10) < 58 ))
                then
                        return 1
                fi
        fi
        return 0
        }

typeset -a _colorNames
typeset -A _colorTable
_gotColors=''

#
# Read colors from local database.
#
function getColors
        {
        local i
        local _color

        #
        # already retrieved, return now
        # 
        if [[ ! -z $_gotColors ]];
        then
                return 0
        fi

        let i=1
        while read -r _color _index
        do
                _colorNames[$i]=$_color
                _colorTable[$_color]=$_index
                (( i++ ))
        done < "${COLORTABLE}"

        _gotColors=true

        if (( $i == 1 ))
        then
                _colorNames=("Black" "Red" "Green" "Yellow" "Blue" "Purple" "Cyan" "White" "Grey")
                _colorTables=("0" "1" "2" "3" "4" "5" "6" "7" "236")
        fi
        }

#
# display colors with names and index numbers
#
function showcolors
        {
        local _color
        local _verbose=''

        getColors

        case $1 in
        -h )
                printf "%s\n" "Show available colors with names and index numbers for prompts."
                printf "%s\n" ""
                printf "%s\n" "Usage:"
                printf "%s\n" "       $0      display colors normally"
                printf "%s\n" "       $0 -h   display this message"
                printf "%s\n" "       $0 -v   display colors spread out for effect"
                return 0
                ;;
        -v )
                _verbose=true
                ;;
        esac

        for _index in {0..255} ;
        do
                let fgrd=16

                isBackgroundDark $_index
                err=$?
                if (( $err != 0 ))
                then
                        (( --fgrd ))
                fi

                _color=$_colorNames[(( _index + 1 ))]

                printf "$(tput setaf ${fgrd})$(tput setab ${_index}) %16.16s [%3d] $(tput sgr0) " $_color $_index
                if (( _index == 7 )) || (( _index == 15 )) || ( (( _index > 15 )) && (( (_index-15) % 6 == 0 )) );
                then
                        printf "$(tput sgr0)\n";
                        if [[ ! -z $_verbose ]];
                        then
                                printf "\n"
                        fi
                fi
        done
        }

VERSION_MAJOR=$(print $ZSH_VERSION|sed 's/^\([^\.]*\).*/\1/')
VERSION_MINOR=$(print $ZSH_VERSION|sed 's/^[^\.]*\.\([^\.]*\)\..*/\1/')

function promptHelp
        {

        printf "%s\n" "prompt: Adjust the command prompt"
        printf "%s\n" "  NOTE: predefined prompts are available with the 'p' command"
        printf "%s\n" ""
        printf "%s\n" "Usage:"
        printf "%s\n" "       prompt {Colors | Snippets}..."
        printf "%s\n" "       prompt -h"
        printf "%s\n" "       prompt -p"
        printf "%s\n" "       prompt -v"
        printf "%s\n" "NOTE: rprompt sets the prompt on the right side of the command line."

        printf "\n"
        printf "%s\n" "   Options:"
        printf "%s\n" "           -h - Display this message."
        printf "%s\n" "           -p - construct the prompt from the 'pstr' or 'rpstr' variables."
        printf "%s\n" "                Use  'pstr+='colors snippets' to build a complex prompt."
        printf "%s\n" "                Use 'rpstr+='colors snippets' to build a prompt to"
        printf "%s\n" "                             display on the right side of the window."
        printf "%s\n" "                Additional arguments on the command line after '-p' will be ignored."
        printf "%s\n" "           -v - print the current prompt command, suitable for saving and executing."
        printf "%s\n" "                Additional arguments on the command line after '-v' will be ignored.\n"

        printf "%s\n" "    Colors:"
        printf "%s\n" "                Black Blue Cyan Grey Green Magenta Red Yellow White"
        printf "%s\n" "                and 246 more; type 'showcolors' to see them."
        printf "%s\n" "        NNN   - select color number NNN (from 0 to 255)"
        printf "%s\n" "        NOTE:   If 2 colors are provided in sequence, the second one"
        printf "%s\n" "                is used as a background color.  A transition symbol"
        printf "%s\n" "                can be specified before a new foreground/background"
        printf "%s\n" "                pair to highlight the change; see Transitions below.\n"

        printf "%s\n" "  Snippets:"

        printf "%s\n" "        .     - add '#' if root, otherwise add '>'"
        printf "%s\n" "        ,     - add '#' if root, otherwise add '$'"
        printf "%s\n" "        B     - (or 'b') toggle Bold text mode"
        printf "%s\n" "        date  - day, month, date: Tue Jan 23"
        printf "%s\n" "        Date  - YYYY-MM-DD: 1996-01-23"
        printf "%s\n" "        dir   - name of current directory"
        printf "%s\n" "        dir2  - name of current directory and its parent"
        printf "%s\n" "        dir3  - name of current directory, its parent and grandparent"
        printf "%s\n" "        Dir   - full path name of current directory"
        printf "%s\n" "        gitb  - git branch in current directory, or 'no repo'"
        printf "%s\n" "        gito  - git downstream and upstream offsets"
        printf "%s\n" "        Gitb  - git branch and offsets in current directory only if one exists"
        printf "%s\n" "                PROMPT_GIT_FORMAT has printf style format, '%s [%s]' by default"
        printf "%s\n" "        hist  - number in command history"
        printf "%s\n" "        host  - hostname"
        printf "%s\n" "        Host  - hostname, fully qualified"
        printf "%s\n" "        id    - display a new icon if the effective user ID is root"
        printf "%s\n" "        lock  - display a lock icon if unable to write in current directory"
        printf "%s\n" "        nl    - newline"
        printf "%s\n" "        os    - operating system icon"
        printf "%s\n" "        path  - full path name of current directory"
        printf "%s\n" "        ret   - last command's return value (or caught signal name)"
        printf "%s\n" "        Ret   - last command's return value, (or signal name) only if non-zero"
        printf "%s\n" "        sp    - space"
        printf "%s\n" "        time  - HH:MM AM/PM"
        printf "%s\n" "        Time  - HH:MM 24-hour clock"
        printf "%s\n" "        ul    - toggle underline text mode"
        printf "%s\n" "        user  - user name"
        printf "%s\n" "        vcs   - version control branch information for git, hg, svn, cvs"
        printf "%s\n" "     <other>  - include <other> literally in the prompt"
        printf "%s\n" "Transitions:"
        printf "%s\n" "        '>' or '<' - arrow transition to new colors (default)"
        printf "%s\n" "        ')' or '(' - curve transition to new colors"
	printf "%s\n" "        #     - pixel block transition to new colors"
	printf "%s\n" "        /     - upward slant transition to new colors"
	printf "%s\n" "        \     - downward slant transition to new colors"
	printf "%s\n" "        ~     - flame transition to new colors"
	printf "%s\n" "        =     - spike transition to new colors"
	printf "%s\n" "        +     - block transition to new colors"
        printf "%s\n" "    Example:"
        printf "%s\n" "        prompt Green user @ host sp Grey30 time sp White hist sp Red Ret White ';'"
        printf "%s\n" "  Currently:"
        printf "%s\n" "         L:     ${pstr}"
        printf "%s\n" "         R:     ${rpstr}"
        }

#
# psvar[1] - vi command line editing mode segment
# psvar[2] - special marker segment if EUID is root
# psvar[3] - Previous command's return code segment
# psvar[4] - Reserved for vcs segment
# psvar[5] - Reserved for Git segment
# psvar[6] - Reserved for Lock segment, when directory is not writable
# psvar[7] - First prompt segment having a single background color
# psvar[8] - Next prompt segment having a single background color
#
PSV_VI=1
PSV_ID=2
PSV_RET=3
PSV_VCS=4
PSV_GIT=5
PSV_LOCK=6
PSV_StartSegment=7

_idPromptUsed=''
_vcsPromptUsed=''
_gitPromptUsed=''
_lockPromptUsed=''

EDIT_MODE_PROMPT=''

#
# This is performed before each prompt is displayed.
# The psvar array contains variables available to the
# prompt which can be updated dynamically
#
function precmd
        {


        #
        # return code analysis must always come first
        #
        psvar[${PSV_RET}]=$?
        if [[ ${psvar[${PSV_RET}]} == 0 ]];
        then
                psvar[${PSV_RET}]=''
        else
                if (( ${psvar[${PSV_RET}]} > 128 ));
                then
                        psvar[${PSV_RET}]=$(kill -l ${psvar[${PSV_RET}]})
                fi
        fi

        if [[ ! -z $_lockPromptUsed ]];
        then
                psvar[${PSV_LOCK}]=''
                if [[ ! -w $PWD ]];
                then
                        psvar[${PSV_LOCK}]="$(print $PROMPT_LOCK)"
                fi
        fi

        if [[ ! -z $_idPromptUsed ]];
        then
                psvar[${PSV_ID}]=''
                if [[ $USERID == 0 ]];
                then
                        psvar[${PSV_ID}]="$(print $PROMPT_ID)"
                fi
        fi

        if [[ ! -z $_vcsPromptUsed ]];
        then
                vcs_info
                if [[ -n $vcs_info_msg_0_ ]];
                then
                        psvar[${PSV_VCS}]="$(print ${PROMPT_GIT_BRANCH} $vcs_info_msg_0_)"
                else
                        psvar[${PSV_VCS}]=''
                fi
        fi

        if [[ ! -z $_gitPromptUsed ]];
        then
                if [[ ! -z $(git-branch-name) ]];
                then
                        psvar[${PSV_GIT}]="$(printf "${PROMPT_GIT_FORMAT}" "$(git-branch-name)" "$(_git-ahead-behind)")"
                else
                        psvar[${PSV_GIT}]=''
                fi
        fi
        }

#
# Set the foreground and background colors, as
# well as a possibly hidden item.  Either a
# request for such an item, or a change in the
# background color is used to indicate a new
# segment.  All segments are added to the
# prompt string
#
function promptSegment
        {
        local _color=$1

        if [[ -z $_fg ]];
        then
                #
                # no foreground color yet, set it now
                #
                _fg=$_color
                _seg+="%F{$_fg}"
                return
        fi

        #
        # foreground color has been set, this must be a background color
        #
        if [[ -z ${_bg} ]];
        then
                #
                # this is first segment
                #
                _bg="$_color"
                if [[ ! -z $_buildRightPrompt ]];
                then
                        _seg+="%F{$_bg}"
                        _seg+="$(print $_rpromptTransition)"
                        _seg+="%F{$_fg}"
                fi
                _seg+="%K{$_bg}"

                #
                # Reset the 'foreground color found' indicator
                #
                _fg=''
                return
        fi

        #
        # for the regular left side prompt, set
        # the foreground to the background color
        #
        if [[ -z $_buildRightPrompt ]];
        then
                _seg+="%F{$_bg}"
        fi

        #
        # If a potentially hidden item was requested
        # for the prompt, then add this segment before
        # closing it off. A check is done before the
        # prompt is displayed to see if the item is
        # supposed to appear.
        #
        case $_checkHiddenSegment in
        Ret)
                psvar[$_segIndex]="%(${PSV_RET}V.${_seg}.)"
                ;;
        lock)
                psvar[$_segIndex]="%(${PSV_LOCK}V?${_seg}?)"
                ;;
        vcs)
                psvar[$_segIndex]="%(${PSV_VCS}V?${_seg}?)"
                ;;
        git)
                psvar[$_segIndex]="%(${PSV_GIT}V?${_seg}?)"
                ;;
        vi)
                psvar[$_segIndex]="%(${PSV_VI}V?${_seg}?)"
                ;;
        id)
                psvar[$_segIndex]="%(${PSV_ID}V?${_seg}?)"
                ;;
        *)
                psvar[$_segIndex]="$_seg"
                ;;
        esac
        _checkHiddenSegment=''

        #
        # here we know that both foreground and background
        # colors are set, and a potentially hidden item
        # has been added if requested.  Close off this
        # current segment and save it.
        #
        (( _segIndex++ ))
        _seg=''
        _bg="$_color"

        if [[ ! -z $_buildRightPrompt ]];
        then
                #
                # draw arrow first with foreground color
                # set to previous background on right side
                # in a new segment
                #
                _seg+="%F{$_bg}"
                _seg+="$(print $_rpromptTransition)"
                _seg+="%K{$_bg}"
        else
                #
                # start a new segment on the left
                #
                _seg+="%K{$_bg}"
                _seg+="$(print $_lpromptTransition)"
        fi
        _seg+="%F{$_fg}"

        #
        # Reset the 'foreground color found' indicator
        #
        _fg=''
        }

#
# fun with prompts.
#
        #
        # zsh prompt sequence "snippets"
        #  %M   hostname
        #  %n   username
        #  %y   tty name
        #  %l   tty name compressed
        #  %%   %
        #  %)   )
        #  %#   a # if root, a % otherwise
        #  %?   status of last executed command
        #  %1d  last component of directory path
        #  %-1d first component of directory path
        #  %0d  full directory path
        #  %d   full directory path
        #  %/   full directory path
        #  %~   full directory path with ~ in place of home
        #  %h   current history command number
        #  %!   current history command number
        #  %j   number of jobs running
        #  %L   value of SHLEVEL
        #  %N   name of function, script currently executing
        #  %D   date yy-mm-dd
        #  %T   time 24-hour
        #  %t   time 12-hour
        #  %@   time 12-hour
        #  %*   time 24-hour with seconds
        #  %w   date day-dd format
        #  %W   date mm-dd-yy format
        #  %D{strftime}  
        #  %B   start bold
        #  %b   stop bold
        #  %E   clear to end of line
        #  %U   start underline
        #  %u   stop underline
        #  %S   start standout
        #  %s   stop standout
        #  %F   start foreground color %F{Green} or %F{10}
        #  %f   stop foreground color
        #  %K   start background color %K{Green} or %K{10}
        #  %k   stop background color

pstr=''
rpstr=''
_buildRightPrompt=''

function prompt
        {

        _lpromptTransition="$PROMPT_L_ARROW_TRANSITION"
        _buildRightPrompt=''
        _commonPrompt $@
        return $?
        }

function rprompt
        {

        _rpromptTransition="$PROMPT_R_ARROW_TRANSITION"
        _buildRightPrompt=true
        _commonPrompt $@
        return $?
        }

function _commonPrompt
        {
        _lpromptSource=''
        _rpromptSource=''

        if [[ $# -eq 0 || $1 == '-h' ]];
        then
                promptHelp
                return 0
        fi

        case $1 in
        -p)
                if [[ ! -z $_buildRightPrompt ]];
                then
                        if [[ ! -z $rpstr ]];
                        then
                                _rpromptSource=$rpstr
                        else
                                promptHelp
                                return 1
                        fi
                else
                        if [[ ! -z $pstr ]];
                        then
                                _lpromptSource=$pstr
                        else
                                promptHelp
                                return 1
                        fi
                fi
                ;;
        -v)
                if [[ ! -z $_buildRightPrompt ]];
                then
                        if [[ -z $rpstr ]];
                        then
                                printf "No right side prompt settings available.\n"
                                promptHelp
                                return 1
                        fi

                        printf "%s\n" "rprompt $rpstr"
                else
                        if [[ -z $pstr ]];
                        then
                                printf "No left side prompt settings available.\n"
                                promptHelp
                                return 1
                        fi

                        printf "%s\n" "prompt $pstr"
                fi
                return 0
                ;;
        -)
                if [[ ! -z $_buildRightPrompt ]];
                then
                        RPS1=''
                else
                        PS1=''
                fi
                return 0
                ;;
        *)
                if [[ ! -z $_buildRightPrompt ]];
                then
                        rpstr="$@"
                        _rpromptSource=$rpstr
                else
                        pstr="$@"
                        _lpromptSource=$pstr
                fi
                ;;
        esac

        getColors

        _boldStarted=''
        _vcsPromptUsed=''
        _gitPromptUsed=''
        _lockPromptUsed=''
        _underlineStarted=''
        _checkHiddenSegment=''
        PROMPT_GIT_FORMAT=${PROMPT_GIT_FORMAT:-"%s [%s]"}

        _fg=''
        _bg=''
        _seg=''

        _segIndex=$PSV_StartSegment

        if [[ ! -z $_buildRightPrompt ]];
        then
                _pSource=(${(s/ /)_rpromptSource})
        else
                _pSource=(${(s/ /)_lpromptSource})
        fi

        for cmd ("${_pSource[@]}");
        do
                #
                # check for color names first
                #
                color=$_colorTable[$cmd]
                if [[ ! -z $color ]];
                then
                        promptSegment $color
                        continue
                fi

                #
                # then check for color indexes
                #
                if [[ $cmd =~ '^[0-9]+$' ]];
                then
                        if (( $cmd >= 0 && $cmd <= 255 ))
                        then
                                promptSegment $cmd
                                continue
                        fi
                fi

                #
                # finally check for symbols
                #
                case $cmd in
                b|B)
                        if [[ ( $VERSION_MAJOR -eq 5 && $VERSION_MINOR -ge 4 ) || $VERSION_MAJOR -gt 5 ]];
                        then
                                if [[ ! -z _boldStarted ]];
                                then
                                        _seg+="%b"
                                        _boldStarted=''
                                else
                                        _seg+="%B"
                                        _boldStarted=true
                                fi
                        fi
                        ;;
                Gitb) 
                        _seg+='${psvar[${PSV_GIT}]}'
                        _checkHiddenSegment="git"
                        _gitPromptUsed=true
                        ;;
                lock)
                        _seg+='${psvar[${PSV_LOCK}]}'
                        _checkHiddenSegment="lock"
                        _lockPromptUsed=true
                        ;;
                id)
                        _seg+='${psvar[${PSV_ID}]}'
                        _checkHiddenSegment="id"
                        _idPromptUsed=true
                        ;;
                os)
                        case $SYS_SPECIFIC in
                        MacOS)
                                _seg+="$(print $PROMPT_MACOS)"
                                ;;
                        centos)
                                _seg+="$(print $PROMPT_CENTOS)"
                                ;;
                        rhel)
                                _seg+="$(print $PROMPT_REDHAT)"
                                ;;
                        ubuntu)
                                _seg+="$(print $PROMPT_UBUNTU)"
                                ;;
                        Linux)
                                _seg+="$(print $PROMPT_LINUX)"
                                ;;
                        *)
                                _seg+="$(print $PROMPT_OTHER)"
                                ;;
                        esac
                        ;;
                Ret)
                        _seg+='${psvar[${PSV_RET}]}'
                        _checkHiddenSegment="Ret"
                        ;;
                ul)
                        if [[ ! -z _underlineStarted ]];
                        then
                                _seg+="%u"
                                _underlineStarted=''
                        else
                                _seg+="%U"
                                _underlineStarted=true
                        fi
                        ;;
                vi)
                        _seg+='${psvar[${PSV_VI}]}'
                        _checkHiddenSegment="vi"
                        ;;
                vcs)
                        _seg+='${psvar[${PSV_VCS}]}'
                        _checkHiddenSegment="vcs"
                        _vcsPromptUsed=true
                        ;;
                date)   _seg+="%D{%a %b %f}"         ;;
                Date)   _seg+="%D{%Y-%m-%d}"         ;;
                Dir)    _seg+="%0d"                  ;;
                dir)    _seg+="%1d"                  ;;
                dir2)   _seg+="%2d"                  ;;
                dir3)   _seg+="%3d"                  ;;
                gitb)   _seg+='$(git-branch)'        ;;
                gito)   _seg+='$(_git-ahead-behind)' ;;
                hist)   _seg+="%h"                   ;;
                Hist)   _seg+="%i"                   ;;
                host)   _seg+="%m"                   ;;
                Host)   _seg+="%M"                   ;;
                nl)     _seg+="\n"                   ;;
                path)   _seg+="%0d"                  ;;
                ret)    _seg+='${psvar[${PSV_RET}]}' ;;
                sp)     _seg+=" "                    ;;
                time)   _seg+="%D{%I:%M %p}"         ;;
                Time)   _seg+="%T"                   ;;
                tty)    _seg+="%y"                   ;;
                user)   _seg+="%n"                   ;;
                ,)      _seg+="\$"                   ;;
                .)      _seg+="%(#.# .>)"            ;;
                #
                # transitions
                #
                '>'|'<')
                        if [[ -z $_buildRightPrompt ]];
                        then
                                _lpromptTransition="$PROMPT_L_ARROW_TRANSITION"
                        else
                                _rpromptTransition="$PROMPT_R_ARROW_TRANSITION"
                        fi
                        ;;
                ')'|'(')
                        if [[ -z $_buildRightPrompt ]];
                        then
                                _lpromptTransition="$PROMPT_L_CURVE_TRANSITION"
                        else
                                _rpromptTransition="$PROMPT_R_CURVE_TRANSITION"
                        fi
                        ;;
                '#')
                        if [[ -z $_buildRightPrompt ]];
                        then
                                _lpromptTransition="$PROMPT_L_PIXEL_TRANSITION"
                        else
                                _rpromptTransition="$PROMPT_R_PIXEL_TRANSITION"
                        fi
                        ;;
                '/')
                        if [[ -z $_buildRightPrompt ]];
                        then
                                _lpromptTransition="$PROMPT_L_UP_TRANSITION"
                        else
                                _rpromptTransition="$PROMPT_R_UP_TRANSITION"
                        fi
                        ;;
                '\')
                        if [[ -z $_buildRightPrompt ]];
                        then
                                _lpromptTransition="$PROMPT_L_DOWN_TRANSITION"
                        else
                                _rpromptTransition="$PROMPT_R_DOWN_TRANSITION"
                        fi
                        ;;
                '~')
                        if [[ -z $_buildRightPrompt ]];
                        then
                                _lpromptTransition="$PROMPT_L_FLAME_TRANSITION"
                        else
                                _rpromptTransition="$PROMPT_R_FLAME_TRANSITION"
                        fi
                        ;;
                '=')
                        if [[ -z $_buildRightPrompt ]];
                        then
                                _lpromptTransition="$PROMPT_L_SPIKE_TRANSITION"
                        else
                                _rpromptTransition="$PROMPT_R_SPIKE_TRANSITION"
                        fi
                        ;;
                '+')
                        if [[ -z $_buildRightPrompt ]];
                        then
                                _lpromptTransition="$PROMPT_BLOCK_TRANSITION"
                        else
                                _rpromptTransition="$PROMPT_BLOCK_TRANSITION"
                        fi
                        ;;
                #
                # anything else
                #
                *)
                        _seg+="${cmd}"
                        ;;
                esac
                _fg=''
        done

        if [[ ! -z _vcsPromptUsed ]];
        then
                zstyle ':vcs_info:*' check-for-changes true
        else
                zstyle ':vcs_info:*' check-for-changes false
        fi

        if [[ ! -z $_bg ]];
        then
                if [[ -z $_buildRightPrompt ]];
                then
                        _seg+="%F{$_bg}"
                fi
                case $_checkHiddenSegment in
                Ret)
                        psvar[$_segIndex]="%(${PSV_RET}V.${_seg}.)"
                        ;;
                lock)
                        psvar[$_segIndex]="%(${PSV_LOCK}V?${_seg}?)"
                        ;;
                vcs)
                        psvar[$_segIndex]="%(${PSV_VCS}V?${_seg}?)"
                        ;;
                git)
                        psvar[$_segIndex]="%(${PSV_GIT}V?${_seg}?)"
                        ;;
                id)
                        psvar[$_segIndex]="%(${PSV_ID}V?${_seg}?)"
                        ;;
                *)
                        psvar[$_segIndex]="$_seg"
                        ;;
                esac
                (( _segIndex++ ))
                _seg="%k"
                if [[ -z $_buildRightPrompt ]];
                then
                        _seg+="$(print $_lpromptTransition)"
                fi
        else
                _seg+="%k"
        fi
        _seg+="%f"
        psvar[$_segIndex]="$_seg"

        #
        # finally fill the prompt string with the segments
        #
        TMP_PROMPT=''
        for (( index = ${PSV_StartSegment}; index <= ${_segIndex}; index++ ))
        do
                if [[ ! -z "${psvar[$index]}" ]];
                then
                        TMP_PROMPT+="${psvar[$index]}"
                fi
        done
        if [[ ! -z $_buildRightPrompt ]];
        then
                RPS1=${TMP_PROMPT}
        else
                PS1=${TMP_PROMPT}
        fi
        return 0
        }

#
# some help to select
# a preset prompt format
#
function presetPromptHelp
        {
        #
        # these messages correspond to the numeric
        # options in the case statement of the 'p'
        # function below.  Specifically, the first
        # prompt refers to case 1) and so forth.
        #
        typeset -A promptOptions
        promptOptions=(
                'mild' 'simple prompt; username and history number'
                'soft'  'color prompt; username, host, directory and history number'
                'light'     'color prompt for light windows with right side indicators and git details'
                'faint'     'color prompt with right side indicators and version control info'
                'tiny'     'vivid simple prompt'
                'small'     'vivid but terse prompt with right side git details and time'
                'min'     'vivid prompt with right side time indicators and git details'
                'beige'     'vivid prompt with brown-ish right side time indicators and version control info'
                'large' 'vivid blue prompt with green right side indicators, version control info, date and time'
                'grey' 'vivid grey prompt with no right side indicators, version control info'
                'sharp' 'vivid prompt; blue left and right side with arrows with date and time'
                'loud'  'vivid prompt; blue left and right side with time'
                )

        printf "%s\n\n" "p: select a preset format for command line prompts:"

        for key in "${(@k)promptOptions}";
        do
                txt=' '
                if [[ $CHOSEN_PRESET_PROMPT == $key ]];
                then
                        txt='>'
                fi
                printf "%-9.9s %s %s\n" "p $key"  "${txt}" "$promptOptions[$key]"
        done
        printf "%s\n" ""
        printf "%s\n" "p -h - display this message"
        printf "%s\n" "Use 'prompt' to adjust prompt details."
        printf "%s\n" " Currently:"
        printf "%s\n" "         L:  ${pstr}"
        printf "%s\n" "         R:  ${rpstr}"
        }

#
# create some
# predefined prompts
#
CHOSEN_PRESET_PROMPT='loud'
function p
        {

        if [[ $# -eq 0 || $1 == '-h' ]];
        then
                presetPromptHelp
                return 0
        fi

        prevChoice=${CHOSEN_PRESET_PROMPT}
        CHOSEN_PRESET_PROMPT=$1
        case $1 in
        "loud")
                #
                # user@sys parent/dir histnum [rootIcon]         [viIcon][retCode][lock][GIT] time
                #
                pstr=''
                pstr+='Grey66 Blue3 user @ White host sp '
                pstr+='> Black Black > '
                pstr+='B White DodgerBlue sp dir2 sp '
                pstr+='> Black Black > '
                pstr+='B Black SkyBlue2 sp hist sp '
                pstr+='White Maroon sp id sp '
                prompt -p

                rpstr=''
                rpstr+='Black PaleGreen1 sp vi sp '
                rpstr+='< Black Black < '
                rpstr+='White DarkRed sp Ret sp '
                rpstr+='Black Orange sp lock sp '
                rpstr+='B White DarkGreen sp vcs sp gito sp '
                rpstr+='< Black Black < '
                rpstr+='B Black SpringGreen3 sp time sp '
                rpstr+='< Black Black < '
                rprompt -p
                ;;
        "grey")
                #
                # user parent/dir histnum [GIT][rootIcon]
                #
                pstr=''
                pstr+='White Grey15 user sp '
                pstr+='> Black Black > '
                pstr+='B Green1 Grey23 sp vcs sp gito sp '
                pstr+='B White Grey35 sp dir2 sp '
                pstr+='> Black Black > '
                pstr+='B White Grey46 sp hist sp '
                pstr+='White Maroon sp id sp '
                prompt -p
                rprompt -
                ;;
        "sharp")
                #
                # user@sys parent/dir histnum [rootIcon]         [viIcon][retCode][lock][GIT] date time
                #
                pstr=''
                pstr+='Grey66 Blue3 user @ White host sp '
                pstr+='> Grey85 DodgerBlue > B White Blue3 dir2 '
                pstr+='> Grey85 DodgerBlue > White Blue3 hist '
                pstr+='> Grey85 DodgerBlue '
                pstr+='White DodgerBlue sp id sp'
                prompt -p

                rpstr=''
                rpstr+='< Black DodgerBlue < '
                rpstr+='B Gold Blue2 vi '
                rpstr+='B DarkOrange Blue2 Ret '
                rpstr+='B Orange Blue2 lock '
                rpstr+='B White Blue2 vcs gito '
                rpstr+='Grey78 Blue2 date '
                rpstr+='< Black DodgerBlue < '
                rpstr+='White Blue2 time '
                rprompt -p
                ;;
        "large")
                #
                # OSicon user@sys parent/dir histnum [rootIcon]         [viIcon][retCode][lock][GIT] date time
                #
                pstr=''
                pstr+='White Black sp os sp '
                pstr+=') B White Blue3 sp user Grey70 @ host sp '
                pstr+='~ B White DodgerBlue sp dir2 sp '
                pstr+='> B Black Turquoise sp hist sp '
                pstr+='White Maroon sp id sp'
                prompt -p

                rpstr=''
                rpstr+='Black Gold sp vi sp '
                rpstr+='White Maroon sp Ret sp '
                rpstr+='Black Orange sp lock sp '
                rpstr+='B White DarkGreen vcs sp gito sp '
                rpstr+='Black SeaGreen2 sp date sp '
                rpstr+='Black DarkSeaGreen2 sp time sp '
                rprompt -p
                ;;
        "beige")
                #
                # OSicon user@sys parent/dir histnum [rootIcon]         [viIcon][retCode][lock][GIT] date time
                #
                pstr=''
                pstr+='White Black sp os sp '
                pstr+='B White Orange3 sp user Cornsilk @ host sp '
                pstr+='B White Yellow5 sp dir2 sp '
                pstr+='B Black DarkGoldenrod sp hist sp '
                pstr+='White Maroon sp id sp'
                prompt -p

                rpstr=''
                rpstr+='Black Gold sp vi sp '
                rpstr+='White Maroon sp Ret sp '
                rpstr+='Black DarkRed sp lock sp '
                rpstr+='< B Black Khaki vcs sp gito sp '
                rpstr+='( Black LightGoldenrod2 sp date sp '
                rpstr+='White Orange2 sp time sp '
                rprompt -p
                ;;
        "min")
                #
                # sys dir histnum [rootIcon]         [viIcon][retCode][lock][GIT] time
                #
                pstr=''
                pstr+='B White Blue3 sp host sp '
                pstr+='~ B White DodgerBlue sp dir sp '
                pstr+='> B Black Turquoise sp hist sp '
                pstr+='White Red sp id sp'
                prompt -p

                rpstr=''
                rpstr+='Black Gold sp vi sp '
                rpstr+='White Maroon sp Ret sp '
                rpstr+='Black Orange sp lock sp '
                rpstr+='B White DarkGreen vcs sp gito sp '
                rpstr+='Black DarkSeaGreen2 sp time sp '
                rprompt -p
                ;;
        "small")
                #
                # dir histnum [rootIcon]         [retCode][lock][GIT] time
                #
                pstr=''
                pstr+='B White DarkGreen sp dir sp '
                pstr+='> Black Black > '
                pstr+='B Black Green2 sp hist sp '
                pstr+='White Maroon sp id sp '
                prompt -p

                rpstr=''
                rpstr+='White DarkRed sp Ret sp '
                rpstr+='Black Orange sp lock sp '
                rpstr+='< Black Black < '
                rpstr+='B White DarkGreen sp vcs sp gito sp '
                rpstr+='< Black Black < '
                rpstr+='B Black SpringGreen3 sp time sp '
                rpstr+='< Black Black < '
                rprompt -p
                ;;
        "tiny")
                #
                # user histnum [rootIcon]
                #
                prompt 'White Blue3 sp user sp dir sp hist sp White Maroon sp id sp'
                rprompt -
                ;;
        "faint")
                #
                # for Dark Screen
                # user@sys parent/dir histnum rootSym         [viIcon] [retCode] [lock] [VCS] date time
                #
                prompt 'B DodgerBlue user @ host CornflowerBlue sp dir2 SkyBlue sp White hist .'

                rpstr=''
                rpstr+='Gold sp vi sp '
                rpstr+='Maroon sp Ret sp '
                rpstr+='SandyBrown sp lock sp '
                rpstr+='LightSkyBlue vcs sp gito sp '
                rpstr+='DodgerBlue sp date sp '
                rpstr+='SkyBlue sp time sp '
                rprompt -p
                ;;
        "light")
                #
                # for Light Screen
                # user@sys parent/dir histnum rootSym         [viIcon] [retCode] [lock] [VCS] date time
                #
                pstr=''
                pstr+='Blue3 user Navy @ host '
                pstr+='sp Black dir2 '
                pstr+='sp Purple4 hist .'
                prompt -p

                rpstr=''
                rpstr+='Gold sp vi sp '
                rpstr+='Maroon sp Ret sp '
                rpstr+='Orange sp lock sp '
                rpstr+='Purple4 sp vcs sp gito sp '
                rpstr+='Maroon sp date sp '
                rpstr+='Blue3 sp time sp '
                rprompt -p
                ;;
        "0"|"soft")
                #
                # user@sys time histnum rootSym
                #
                prompt 'B DodgerBlue user @ host sp SkyBlue time sp White hist .'
                rprompt -
                ;;
        "mild")
                #
                # user@sys histnum rootSym
                #
                prompt 'White user sp hist .'
                rprompt -
                ;;
        *)
                #
                # false alarm - reset the preset prompt choice
                #
                CHOSEN_PRESET_PROMPT=${prevChoice}
                echo "Unrecognized prompt: '$1'"
                echo ""
                presetPromptHelp
                return 0
                ;;
        esac
        }
#
# start with a simple colored prompt and check for warp terminal
#

p ${CHOSEN_PRESET_PROMPT}
if [[ $TERM_PROGRAM = "WarpTerminal" ]];
then
        PROMPT="${PROMPT}"$'\n'
fi

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
_checkAndRead "${_STARTUP_DIR}"/dirs.zsh

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#
# the fun start here
#
setupCommands

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# zsh-hostSpecificSetup
_checkAndRead "${_STARTUP_DIR}"/hostSpecificSetup.sh

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#
# Set up host-specific environment variables
#
hostSpecificSetup
findVim

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

